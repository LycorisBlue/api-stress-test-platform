package main

import (
   "encoding/json"
   "fmt"
   "log"
   "net/http"
   "os"
   "path/filepath"
   "strconv"
   "time"
)

// APIRequest repr√©sente une requ√™te d'ex√©cution de test re√ßue de l'orchestrateur
type APIRequest struct {
   TestID    string    `json:"test_id"`
   Config    TestConfig `json:"config"`
   Timestamp time.Time `json:"timestamp"`
}

// APIResponse repr√©sente la r√©ponse envoy√©e √† l'orchestrateur
type APIResponse struct {
   Status    string      `json:"status"`
   Message   string      `json:"message"`
   TestID    string      `json:"test_id,omitempty"`
   Summary   *TestSummary `json:"summary,omitempty"`
   ReportPath string     `json:"report_path,omitempty"`
   Error     string      `json:"error,omitempty"`
}

// HealthResponse repr√©sente la r√©ponse du endpoint /health
type HealthResponse struct {
   Status    string `json:"status"`
   Component string `json:"component"`
   Timestamp string `json:"timestamp"`
   Version   string `json:"version"`
}

// Configuration globale du worker
var (
   serverPort     = getEnvOrDefault("WORKER_PORT", "8090")
   orchestratorURL = getEnvOrDefault("ORCHESTRATOR_URL", "http://orchestrator:8080")
   workerVersion  = "1.0.0"
)

func main() {
   log.Printf("üöÄ D√©marrage du Worker Go v%s", workerVersion)
   log.Printf("üì° Port d'√©coute: %s", serverPort)
   log.Printf("üéØ Orchestrateur: %s", orchestratorURL)
   
   // Initialiser les r√©pertoires de travail
   if err := initializeDirectories(); err != nil {
   	log.Fatalf("‚ùå Erreur d'initialisation: %v", err)
   }
   
   // Configurer les routes HTTP
   setupRoutes()
   
   // D√©marrer le serveur HTTP
   log.Printf("‚úÖ Worker pr√™t - Listening on :%s", serverPort)
   if err := http.ListenAndServe(":"+serverPort, nil); err != nil {
   	log.Fatalf("‚ùå Erreur serveur HTTP: %v", err)
   }
}

// setupRoutes configure toutes les routes HTTP du worker
func setupRoutes() {
   http.HandleFunc("/health", handleHealth)
   http.HandleFunc("/execute", handleExecuteTest)
   http.HandleFunc("/status", handleStatus)
   http.HandleFunc("/reports", handleListReports)
   http.HandleFunc("/reports/", handleGetReport)
   http.HandleFunc("/cleanup", handleCleanup)
}

// handleHealth endpoint de sant√© pour les health checks
func handleHealth(w http.ResponseWriter, r *http.Request) {
   if r.Method != http.MethodGet {
   	http.Error(w, "M√©thode non autoris√©e", http.StatusMethodNotAllowed)
   	return
   }
   
   response := HealthResponse{
   	Status:    "ok",
   	Component: "worker",
   	Timestamp: time.Now().Format(time.RFC3339),
   	Version:   workerVersion,
   }
   
   w.Header().Set("Content-Type", "application/json")
   json.NewEncoder(w).Encode(response)
}

// handleExecuteTest endpoint principal pour ex√©cuter un test
func handleExecuteTest(w http.ResponseWriter, r *http.Request) {
   if r.Method != http.MethodPost {
   	http.Error(w, "M√©thode non autoris√©e", http.StatusMethodNotAllowed)
   	return
   }
   
   log.Printf("üì® R√©ception d'une demande d'ex√©cution de test")
   
   // Lire et parser la requ√™te
   var apiRequest APIRequest
   if err := json.NewDecoder(r.Body).Decode(&apiRequest); err != nil {
   	log.Printf("‚ùå Erreur de parsing de la requ√™te: %v", err)
   	respondWithError(w, "Erreur de parsing de la requ√™te", http.StatusBadRequest)
   	return
   }
   
   // Valider la configuration re√ßue
   if err := validateTestConfig(apiRequest.Config); err != nil {
   	log.Printf("‚ùå Configuration invalide: %v", err)
   	respondWithError(w, fmt.Sprintf("Configuration invalide: %v", err), http.StatusBadRequest)
   	return
   }
   
   log.Printf("‚úÖ Configuration valid√©e - Mode: %s, Sc√©nario: %s", 
   	apiRequest.Config.Mode, apiRequest.Config.Scenario.Name)
   
   // Cr√©er le collecteur de m√©triques
   collector := NewMetricsCollector()
   
   // Ex√©cuter le test
   log.Printf("üèÉ D√©marrage de l'ex√©cution du test %s", apiRequest.TestID)
   testResult := ExecuteTest(apiRequest.Config, collector)
   
   // G√©n√©rer et sauvegarder le rapport
   reportPath, err := SaveTestReport(testResult, apiRequest.Config, collector)
   if err != nil {
   	log.Printf("‚ö†Ô∏è Erreur de sauvegarde du rapport: %v", err)
   	// Continuer malgr√© l'erreur de sauvegarde
   } else {
   	log.Printf("üìÑ Rapport sauv√©: %s", reportPath)
   }
   
   // G√©n√©rer le r√©sum√© pour la r√©ponse
   summary := GenerateTestSummary(testResult, collector)
   
   // Pr√©parer la r√©ponse
   response := APIResponse{
   	Status:     "completed",
   	Message:    fmt.Sprintf("Test termin√© avec le statut: %s", testResult.Status),
   	TestID:     apiRequest.TestID,
   	Summary:    &summary,
   	ReportPath: reportPath,
   }
   
   if testResult.Status == "failed" {
   	response.Error = testResult.ErrorMsg
   }
   
   // Log du r√©sultat
   log.Printf("‚úÖ Test %s termin√© - Statut: %s, Requ√™tes: %d, RPS: %.1f", 
   	apiRequest.TestID, testResult.Status, summary.TotalRequests, summary.RequestsPerSecond)
   
   // Envoyer la r√©ponse
   w.Header().Set("Content-Type", "application/json")
   json.NewEncoder(w).Encode(response)
}

// handleStatus endpoint pour obtenir le statut actuel du worker
func handleStatus(w http.ResponseWriter, r *http.Request) {
   if r.Method != http.MethodGet {
   	http.Error(w, "M√©thode non autoris√©e", http.StatusMethodNotAllowed)
   	return
   }
   
   // Compter les rapports disponibles
   reports, _ := ListTestReports()
   
   status := map[string]interface{}{
   	"status":         "ready",
   	"component":      "worker",
   	"version":        workerVersion,
   	"timestamp":      time.Now().Format(time.RFC3339),
   	"reports_count":  len(reports),
   	"orchestrator":   orchestratorURL,
   }
   
   w.Header().Set("Content-Type", "application/json")
   json.NewEncoder(w).Encode(status)
}

// handleListReports endpoint pour lister tous les rapports disponibles
func handleListReports(w http.ResponseWriter, r *http.Request) {
   if r.Method != http.MethodGet {
   	http.Error(w, "M√©thode non autoris√©e", http.StatusMethodNotAllowed)
   	return
   }
   
   reports, err := ListTestReports()
   if err != nil {
   	log.Printf("‚ùå Erreur de listage des rapports: %v", err)
   	respondWithError(w, "Erreur de listage des rapports", http.StatusInternalServerError)
   	return
   }
   
   response := map[string]interface{}{
   	"status":  "success",
   	"count":   len(reports),
   	"reports": reports,
   }
   
   w.Header().Set("Content-Type", "application/json")
   json.NewEncoder(w).Encode(response)
}

// handleGetReport endpoint pour r√©cup√©rer un rapport sp√©cifique
func handleGetReport(w http.ResponseWriter, r *http.Request) {
   if r.Method != http.MethodGet {
   	http.Error(w, "M√©thode non autoris√©e", http.StatusMethodNotAllowed)
   	return
   }
   
   // Extraire le nom du fichier de l'URL (/reports/filename.json)
   filename := filepath.Base(r.URL.Path)
   if filename == "reports" || filename == "" {
   	respondWithError(w, "Nom de fichier manquant", http.StatusBadRequest)
   	return
   }
   
   // Construire le chemin complet
   filePath := filepath.Join(GetReportsDirectory(), filename)
   
   // V√©rifier que le fichier existe
   if _, err := os.Stat(filePath); os.IsNotExist(err) {
   	respondWithError(w, "Rapport non trouv√©", http.StatusNotFound)
   	return
   }
   
   // Lire et retourner le fichier
   data, err := os.ReadFile(filePath)
   if err != nil {
   	log.Printf("‚ùå Erreur de lecture du rapport %s: %v", filename, err)
   	respondWithError(w, "Erreur de lecture du rapport", http.StatusInternalServerError)
   	return
   }
   
   w.Header().Set("Content-Type", "application/json")
   w.Write(data)
}

// handleCleanup endpoint pour nettoyer les anciens rapports
func handleCleanup(w http.ResponseWriter, r *http.Request) {
   if r.Method != http.MethodPost {
   	http.Error(w, "M√©thode non autoris√©e", http.StatusMethodNotAllowed)
   	return
   }
   
   // Lire le param√®tre de dur√©e (par d√©faut 7 jours)
   maxAgeDays := 7
   if daysStr := r.URL.Query().Get("days"); daysStr != "" {
   	if days, err := strconv.Atoi(daysStr); err == nil && days > 0 {
   		maxAgeDays = days
   	}
   }
   
   maxAge := time.Duration(maxAgeDays) * 24 * time.Hour
   
   log.Printf("üßπ Nettoyage des rapports plus anciens que %d jours", maxAgeDays)
   
   if err := CleanupOldReports(maxAge); err != nil {
   	log.Printf("‚ùå Erreur de nettoyage: %v", err)
   	respondWithError(w, "Erreur de nettoyage", http.StatusInternalServerError)
   	return
   }
   
   response := map[string]interface{}{
   	"status":  "success",
   	"message": fmt.Sprintf("Nettoyage effectu√© (fichiers > %d jours)", maxAgeDays),
   }
   
   w.Header().Set("Content-Type", "application/json")
   json.NewEncoder(w).Encode(response)
}

// validateTestConfig valide la configuration d'un test
func validateTestConfig(config TestConfig) error {
   // V√©rifier le mode
   if config.Mode != "users" && config.Mode != "requests" {
   	return fmt.Errorf("mode invalide: %s (doit √™tre 'users' ou 'requests')", config.Mode)
   }
   
   // V√©rifier les param√®tres selon le mode
   if config.Mode == "users" && config.VirtualUsers <= 0 {
   	return fmt.Errorf("virtualUsers doit √™tre > 0 en mode 'users'")
   }
   
   if config.Mode == "requests" && config.TotalRequests <= 0 {
   	return fmt.Errorf("totalRequests doit √™tre > 0 en mode 'requests'")
   }
   
   // V√©rifier le sc√©nario
   if config.Scenario.Name == "" {
   	return fmt.Errorf("nom du sc√©nario manquant")
   }
   
   if len(config.Scenario.Steps) == 0 {
   	return fmt.Errorf("le sc√©nario doit avoir au moins une √©tape")
   }
   
   // V√©rifier chaque √©tape
   for i, step := range config.Scenario.Steps {
   	if step.Name == "" {
   		return fmt.Errorf("√©tape %d: nom manquant", i+1)
   	}
   	if step.Method == "" {
   		return fmt.Errorf("√©tape %d (%s): m√©thode HTTP manquante", i+1, step.Name)
   	}
   	if step.URL == "" {
   		return fmt.Errorf("√©tape %d (%s): URL manquante", i+1, step.Name)
   	}
   }
   
   return nil
}

// respondWithError envoie une r√©ponse d'erreur format√©e
func respondWithError(w http.ResponseWriter, message string, statusCode int) {
   response := APIResponse{
   	Status:  "error",
   	Message: message,
   	Error:   message,
   }
   
   w.Header().Set("Content-Type", "application/json")
   w.WriteHeader(statusCode)
   json.NewEncoder(w).Encode(response)
}

// initializeDirectories cr√©e les r√©pertoires de travail n√©cessaires
func initializeDirectories() error {
   dirs := []string{
   	"/tmp/loadtest",
   	"/tmp/loadtest/results",
   	"/tmp/loadtest/config",
   }
   
   for _, dir := range dirs {
   	if err := os.MkdirAll(dir, 0755); err != nil {
   		return fmt.Errorf("impossible de cr√©er le r√©pertoire %s: %w", dir, err)
   	}
   }
   
   log.Printf("üìÅ R√©pertoires de travail initialis√©s")
   return nil
}

// getEnvOrDefault r√©cup√®re une variable d'environnement ou retourne une valeur par d√©faut
func getEnvOrDefault(envVar, defaultValue string) string {
   if value := os.Getenv(envVar); value != "" {
   	return value
   }
   return defaultValue
}

// registerWithOrchestrator enregistre ce worker aupr√®s de l'orchestrateur
func registerWithOrchestrator() error {
   // Cette fonction pourrait √™tre utilis√©e pour un auto-discovery
   // Pour l'instant, on utilise une configuration statique
   log.Printf("üîó Worker configur√© pour communiquer avec %s", orchestratorURL)
   return nil
}

// logRequestDetails affiche les d√©tails d'une requ√™te pour le debugging
func logRequestDetails(r *http.Request) {
   log.Printf("üì® %s %s - Remote: %s, User-Agent: %s", 
   	r.Method, r.URL.Path, r.RemoteAddr, r.Header.Get("User-Agent"))
}

// Fonction d'initialisation appel√©e au d√©marrage
func init() {
   // Configuration du logger
   log.SetFlags(log.LstdFlags | log.Lshortfile)
   log.SetPrefix("[WORKER] ")
   
   // Banner de d√©marrage
   fmt.Println(`
   ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
   ‚ïë        Load Test Worker          ‚ïë
   ‚ïë         Go Version 1.22          ‚ïë
   ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
   `)
}